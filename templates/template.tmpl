{{define "bulkInsertFile"}}
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc {{.SqlcVersion}}

package {{.Package}}

import (
  "context"
  "fmt"
  "reflect"
  "strings"
)

// extractFieldValues takes a slice of a structure and an ordered list of field names to extract,
// extracts field values from all structures in the specified order and returns them as a flat []any slice.
func extractFieldValues[T any](args []T, paramFieldNames []string) ([]any, error) {
  values := make([]any, 0, len(args)*len(paramFieldNames))
  if len(paramFieldNames) == 0 {
    return values, nil
  }

  for i, arg := range args {
    rv := reflect.ValueOf(arg)
    if rv.Kind() == reflect.Ptr {
      rv = rv.Elem()
    }

    if rv.Kind() != reflect.Struct {
      return nil, fmt.Errorf("args[%d] (type %T) is not a struct or pointer to struct", i, arg)
    }

    for _, fieldName := range paramFieldNames {
      field := rv.FieldByName(fieldName)
      if !field.IsValid() {
        return nil, fmt.Errorf("args[%d] (type %T): field '%s' not found", i, arg, fieldName)
      }
      if !field.CanInterface() {
        return nil, fmt.Errorf("args[%d] (type %T): field '%s' cannot be interfaced (not exported or unaddressable)", i, arg, fieldName)
      }
      values = append(values, field.Interface())
    }
  }
  return values, nil
}

// buildBulkInsertQuery builds a SQL query string for bulk inserts.
// originalQuery: the original INSERT statement (e.g., "INSERT INTO users (id, name) VALUES ($1, $2)")
// numArgs: number of rows of data to insert
// numParamsPerArg: number of parameters per row (number of columns)
func buildBulkInsertQuery(originalQuery string, numArgs int, numParamsPerArg int) (string, error) {
  if numArgs == 0 {
    return "", fmt.Errorf("number of arguments (rows) for bulk insert cannot be zero")
  }
  if numParamsPerArg == 0 {
    return "", fmt.Errorf("number of parameters per argument (columns) for bulk insert cannot be zero")
  }

  // Extract the "INSERT INTO table (col1, col2) VALUES " part from the original query
  // First, remove the trailing semicolon, if any
  trimmedQuery := strings.TrimSpace(originalQuery)
  if strings.HasSuffix(trimmedQuery, ";") {
    trimmedQuery = trimmedQuery[:len(trimmedQuery)-1]
  }

  // search "VALUES" (case insensitive)
  valuesUpperIndex := strings.LastIndex(strings.ToUpper(trimmedQuery), "VALUES")
  if valuesUpperIndex == -1 {
    return "", fmt.Errorf("invalid query format: VALUES clause not found in original query: %s", originalQuery)
  }

  // Prefix the query up to "VALUES".
  // (e.g., "INSERT INTO users (id, name)")
  // Add "VALUES" to this
  queryPrefixStr := strings.TrimSpace(trimmedQuery[:valuesUpperIndex]) + " VALUES "

  var queryBuilder strings.Builder
  queryBuilder.WriteString(queryPrefixStr)

  valueStrings := make([]string, numArgs)
  for i := 0; i < numArgs; i++ {
    placeholders := make([]string, numParamsPerArg)
    for j := 0; j < numParamsPerArg; j++ {
      placeholders[j] = "?"
    }
    valueStrings[i] = fmt.Sprintf("(%s)", strings.Join(placeholders, ","))
  }
  queryBuilder.WriteString(strings.Join(valueStrings, ","))
  return queryBuilder.String(), nil
}

{{range .BulkInsert}}
{{ $queryName := .QueryName }}
{{ $paramFieldNames := .ParamFieldNames }}
{{ $originalQueryConstantName := lowerTitle $queryName }} {{/* Query string constant name generated by the original sqlc */}}

// Bulk{{$queryName}}Params is a slice type of {{.QueryName}}Params.
// The {{.QueryName}}Params type is assumed to be generated by sqlc based on the original {{.QueryName}} query.
type Bulk{{$queryName}}Params []{{$queryName}}Params

// Bulk{{$queryName}} executes a bulk insert with the specified argument slice.
func (q *Queries) Bulk{{$queryName}}(ctx context.Context, args Bulk{{$queryName}}Params) error {
  if len(args) == 0 {
    return nil
  }

  // Query string constant name generated by the original sqlc
  originalQuery := {{$originalQueryConstantName}}

  // Define this as a variable in the Go code
  paramFieldNamesForQuery := {{stringSliceLiteral .ParamFieldNames}}

  bulkSQL, err := buildBulkInsertQuery(originalQuery, len(args), len(paramFieldNamesForQuery))
  if err != nil {
    return fmt.Errorf("failed to build bulk insert query for {{$queryName}}: %w", err)
  }

  preparedValues, err := extractFieldValues(args, paramFieldNamesForQuery)
  if err != nil {
    return fmt.Errorf("failed to extract field values for {{$queryName}}: %w", err)
  }

  if q.db == nil {
    return fmt.Errorf("Queries.db is nil")
  }
  _, err = q.db.ExecContext(ctx, bulkSQL, preparedValues...)
  return err
}
{{end}}
{{end}}
