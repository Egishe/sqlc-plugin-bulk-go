package main

import (
	"strings"
	"unicode"

	"github.com/sqlc-dev/plugin-sdk-go/plugin"
)

type BulkInsert struct {
	// QueryName is the name of the SQL query, corresponding to the Go function name generated by sqlc
	QueryName string
	// Go field names corresponding to the INSERT column order
	ParamFieldNames []string
	// Original SQL query string (for placeholder generation)
	OriginalQuery string
}

type BulkInserts []BulkInsert

func buildBulkInsert(
	req *plugin.GenerateRequest, _ *Options,
) BulkInserts {
	slices := make([]BulkInsert, 0)
	for _, query := range req.GetQueries() {
		// For queries that are INSERT statements and of the type where sqlc generates a parameter structure
		// If query.GetCmd() is an empty string, it may be different from something like a simple :exec
		// Assumes parameters are defined in the INSERT statement
		if !strings.HasPrefix(strings.ToUpper(query.GetText()), "INSERT INTO") || len(query.GetParams()) == 0 {
			continue
		}

		paramFieldNames := make([]string, 0, len(query.GetParams()))
		for _, p := range query.GetParams() {
			if p.GetColumn() == nil {
				continue
			}
			nameFromPlugin := p.GetColumn().GetName()
			goFieldName := snakeToPascalCase(nameFromPlugin)
			paramFieldNames = append(paramFieldNames, goFieldName)
		}

		// INSERT statements that fail to get any parameters are skipped (usually len(query.GetParams()) == 0)
		if len(paramFieldNames) == 0 {
			continue
		}

		slices = append(slices, BulkInsert{
			QueryName:       query.GetName(),
			ParamFieldNames: paramFieldNames,
			OriginalQuery:   query.GetText(),
		})
	}
	return slices
}

// snakeToPascalCase converts a snake case string to a Pascal case.
// certain words such as "id" are treated as uppercase, as in "ID".
// Example: "user_id" -> "UserID", "email" -> "Email"
func snakeToPascalCase(snakeStr string) string {
	if snakeStr == "" {
		return ""
	}

	// map a specific word to the expected capitalization.
	// This map can be extended as needed.
	// (Keys are written in lowercase and are also converted to lowercase for comparison and matching)
	commonInitialisms := map[string]string{
		"id":   "ID",
		"url":  "URL",
		"api":  "API",
		"json": "JSON",
		"xml":  "XML",
		"html": "HTML",
	}

	var result strings.Builder
	parts := strings.Split(snakeStr, "_")

	for _, part := range parts {
		if part == "" {
			continue
		}

		// Check if the whole part matches the lower case key of the common acronym
		// (e.g., match as "id" even if part is "id", "Id", "iD", or "ID")
		if initialism, ok := commonInitialisms[strings.ToLower(part)]; ok {
			result.WriteString(initialism)
		} else {
			runes := []rune(part)
			if len(runes) > 0 {
				result.WriteRune(unicode.ToUpper(runes[0]))
				if len(runes) > 1 {
					result.WriteString(string(runes[1:]))
				}
			}
		}
	}
	return result.String()
}
